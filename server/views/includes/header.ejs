<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
<script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>

<link rel="stylesheet" href="/style.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

<link rel="apple-touch-icon" sizes="180x180" href="/branding/fav/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/branding/fav/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/branding/fav/favicon-16x16.png">
<link rel="manifest" href="/branding/fav/site.webmanifest">
<link rel="mask-icon" href="/branding/fav/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
<script src="/js/login.js"></script>
<script>
    function showNotification(message, type = 'info', duration = 3000, callback = null) {
        let baseClass = 'notificationBar';
        let typeClass = `notification-${type}`;

        // Check if the notificationBar already exists, if not, create it
        let $notificationBar = $('#' + baseClass);
        if ($notificationBar.length === 0) {
            $notificationBar = $('<div></div>', {
                id: baseClass,
                class: baseClass
            }).appendTo('body');
        }

        // Update message and class based on the type
        $notificationBar.text(message).removeClass().addClass(baseClass + ' ' + typeClass).fadeIn(200);

        // Hide the notificationBar after 'duration' milliseconds and execute the callback if provided
        setTimeout(function () {
            $notificationBar.fadeOut(200, function () {
                if (typeof callback === 'function') {
                    callback();
                }
            });
        }, duration);
    }

    function isJwtExpired(token) {
        if (!token) return true; // No token means "expired"

        try {
            const base64Url = token.split('.')[1]; // JWT structure: Header.Payload.Signature
            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            const payload = JSON.parse(window.atob(base64));

            // JWT exp is in seconds
            const now = new Date().getTime() / 1000; // Convert to seconds
            return payload.exp < now;
        } catch (error) {
            console.error("Error decoding token:", error);
            return true; // Assume expired on any error
        }
    }


    function requireLoginBeforeAction() {
        const authToken = localStorage.getItem('authToken');

        if (!authToken || isJwtExpired(authToken)) {
            // No token or expired token, show login modal
            $('#loginModal').show();
            return false; // Prevent the default form action or click event
        }

        return true; // User is logged in, continue with the action
    }

    $(document).on('click', 'form, textarea, .ql-editor', function (e) {
        // Check if the clicked element or any of its parents is #loginRegisterForm
        if ($(e.target).closest('#loginRegisterForm').length) {
            // If true, it means the click originated from inside #loginRegisterForm or is #loginRegisterForm itself
            // Do nothing and return early
            return;
        }

        if (!localStorage.getItem('authToken') || isJwtExpired(localStorage.getItem('authToken'))) {
            e.preventDefault(); // Prevent the default action
            // Display the login form
            $('#loginRegisterForm').css('display', 'flex');
        }
    });

    function processHTMLFromUsers(content) {
        if (!content) {
            return content;
        }

        function cleanHtmlContent(content) {

            // replace space with empty string
            content = content.replace(/&nbsp;/gi, ' ');

            // trim leading and trailing spaces
            // causes spaces removed around links
            // content = content.replace(/(>)[\s]+/g, '$1').replace(/[\s]+(<)/g, '$1');

            // This regex removes tags that contain only whitespace or a single <br> tag, in addition to entirely empty tags
            return content.replace(/<(\w+)(?:\s+[^>]*)?>\s*(<br\s*\/?>)?\s*<\/\1>/g, '');
        }

        function removeDangerousTags(html) {
            // Remove script tags and their content
            html = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');

            // You can add more lines here to remove other potentially dangerous tags
            // Example: Remove iframe tags
            // html = html.replace(/<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi, '');

            return html;
        }

        function removeAllAttributesExceptLinks(html) {
            // This regex looks for HTML tags that are not <a> and attempts to remove attributes inside them
            // It will leave <a href="..."> tags untouched
            const cleanHtml = html.replace(/<((?!a\b)\w+)(\s+[^>]+)?(>)/g, '<$1$3');
            return cleanHtml;
        }

        // Step 1: Clean the content (if needed, like removing &nbsp; or empty tags)
        content = cleanHtmlContent(content);

        // Step 2: Remove dangerous tags like <script>
        content = removeDangerousTags(content);

        // Step 3: Keep only <a> tags with href and optionally target="_blank", remove all other attributes
        content = content.replace(/<a\b[^>]*>/gi, function (match) {
            const hrefMatch = match.match(/\bhref="[^"]*"/i);
            const targetMatch = match.match(/\btarget="_blank"/i);
            return `<a ${hrefMatch ? hrefMatch[0] : ''} ${targetMatch ? targetMatch[0] : ''}>`;
        });

        // Step 4: Remove attributes from all other tags
        content = removeAllAttributesExceptLinks(content);

        return content;
    }


    function validateComment(content) {
        const minLength = 6;
        const maxLength = 60000;

        // Trim whitespace from start and end of the comment content
        let trimmedContent = content.trim();

        // Remove specific characters and strings for the uniqueness check
        const charsAndSpacesToRemove = /<p>|<\/p>|<|>|p|\/|\s/gi;
        trimmedContent = trimmedContent.replace(charsAndSpacesToRemove, '');


        // Check for empty content or content that only has spaces or tab characters
        if (!trimmedContent) {
            return { isValid: false, message: "Comment cannot be empty." };
        }

        // Check for content length below minimum
        if (trimmedContent.length < minLength) {
            return { isValid: false, message: `Comment must be at least ${minLength} characters long.` };
        }

        // Check for content length exceeding maximum
        if (trimmedContent.length > maxLength) {
            return { isValid: false, message: `Comment must not exceed ${maxLength} characters.` };
        }

        const unsubstantiveTexts = [
            "hi", "hello", "hey", "thanks", "thank you", "thx", "good", "great", "nice", "ok", "okay",
            "lol", "haha", "hehe", "cool", "yes", "no", "yep", "nope", "wow", "omg", "ugh", "hmm",
            "meh", "yay", "nah", "pls", "please", "bye", "goodbye", "see ya", "idk", "imo", "imho",
            "fyi", "brb", "gtg", "k", "kk", "üëç", "üëé", "üòÇ", "üòç", "üò≠", "üòä", "üòí", "üòâ", "üòú", "üôÑ"
        ];

        // Check for unsubstantive text content
        if (unsubstantiveTexts.includes(trimmedContent.toLowerCase())) {
            return { isValid: false, message: "Comment is too short or unsubstantive." };
        }

        // Check for at least 4 unique characters, ignoring specific tags and characters
        const uniqueChars = new Set(trimmedContent).size;
        if (uniqueChars < 5) {
            return { isValid: false, message: "Comment is too short or unsubstantive." };
        }

        // If the content passes all checks
        return { isValid: true, message: "" };
    }

    function timeAgo(date) {
    const intervals = [
        { label: 'year', seconds: 31536000 },
        { label: 'month', seconds: 2592000 },
        { label: 'day', seconds: 86400 },
        { label: 'hour', seconds: 3600 },
        { label: 'minute', seconds: 60 },
        { label: 'second', seconds: 1 }
    ];

    const seconds = Math.floor((Date.now() - new Date(date).getTime()) / 1000);
    const interval = intervals.find(i => i.seconds <= seconds);

    if (interval) {
        const count = Math.floor(seconds / interval.seconds);
        return `${count} ${interval.label}${count !== 1 ? 's' : ''} ago`;
    } else {
        // This line is reached if no matching interval is found
        return "just now"; // Fallback text or you can adjust this as needed
    }
}



</script>


</head>

<body>

    <div id="logo_cont">
        <a href="/"><img id="logo_satori1" src="/branding/azodu.png" /></a>
    </div>

    <div id="loginRegisterForm" class="lightbox" style="display: none;">
        <div class="lightbox-content">
            <h2 id="formTitle">Login</h2>
            <form id="authForm">
                <input type="text" id="username" placeholder="Username" required>
                <input type="password" id="password" placeholder="Password" required>
                <input type="submit" id="submitAuth" value="Login">
                <div id="formMessage" style="color: #d7dadc; margin-top: 10px;"></div> <!-- Message placeholder -->
                <p id="switchAuthMode">Don't have an account? <a href="#" id="switchForm">Register here.</a></p>
            </form>
        </div>
    </div>