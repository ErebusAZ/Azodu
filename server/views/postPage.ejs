<!DOCTYPE html>
<html lang="en">

<head>

    <title>
        Azodu - <%= post.title %>
    </title>


    <%- include('includes/header') %>


        <script>

            var post = <%- JSON.stringify(post) %>;

            var category = <%- JSON.stringify(category) %>;


            function scrollToComment() {
                const commentId = window.location.hash; // e.g., "#comment-12345"
                if (commentId) {
                    const commentElement = document.querySelector(commentId);

                    if (commentElement) {
                        commentElement.scrollIntoView({ behavior: "smooth", block: "start" });
                        commentElement.style.backgroundColor = "#5b5703";

                    } else {

                        console.log('Comment not loaded yet. Implement logic to load the comment.');
                    }
                }
            }

            function organizeComments(comments, sortBy = 'top') {
                const commentsMap = {};

                // Initialize each comment with an empty 'replies' array and calculate points
                comments.forEach(comment => {
                    const points = comment.upvotes - comment.downvotes;
                    const controversialScore = Math.min(comment.upvotes, comment.downvotes); // For 'controversial' sorting

                    commentsMap[comment.comment_id] = { ...comment, replies: [], points, controversialScore };
                });

                // Populate the 'replies' array for parent comments
                comments.forEach(comment => {
                    if (comment.parent_id !== comment.post_id) {
                        if (commentsMap[comment.parent_id]) {
                            commentsMap[comment.parent_id].replies.push(commentsMap[comment.comment_id]);
                        } else {
                            console.error(`Missing parent comment for comment_id: ${comment.comment_id} with parent_id: ${comment.parent_id}`);
                        }
                    }
                });

                // Define a sorting function based on the sortBy parameter
                const sortFunction = (a, b) => {
                    switch (sortBy) {
                        case 'top':
                            return b.points - a.points;
                        case 'newest':
                            return new Date(b.timestamp) - new Date(a.timestamp);
                        case 'controversial':
                            return b.controversialScore - a.controversialScore;
                        default:
                            return b.points - a.points; // Default to sorting by 'top'
                    }
                };

                // Sort replies of each comment
                Object.values(commentsMap).forEach(comment => {
                    if (comment.replies.length > 0) {
                        comment.replies.sort(sortFunction);
                    }
                });

                // Filter out top-level comments (direct replies to the post), sort them, and return
                return comments.filter(comment => comment.parent_id === comment.post_id)
                    .map(comment => commentsMap[comment.comment_id])
                    .sort(sortFunction);
            }




            function renderComments(comments, depth = 0,postPermalink) {
                let html = ''; // Start with an empty string
                comments.forEach(comment => {
                    // Use getCommentHtml with individual parameters
                    html += getCommentHtml(comment.comment_id, comment.author, comment.content, depth, comment.upvotes - comment.downvotes, comment.timestamp,comment.parent_id,undefined,postPermalink,false,category.creator,post.author);

                    // Check for replies and recursively render them
                    if (comment.replies && comment.replies.length > 0) {
                        html += renderComments(comment.replies, depth + 1,postPermalink); // Increment depth for nested comments
                    }
                });

                return html;
            }

            // Use the functions
            const organizedComments = organizeComments(post.comments);
            const commentsHTML = renderComments(organizedComments,0,post.permalink);


            // In an EJS template, you might then inject commentsHTML where appropriate






            $(document).ready(function () {

                // hide the comment sort dropdown
                if (Object.keys(post.comments).length > 0)
                    $('.sort-container').css({ 'display': 'block' });

                const organizedComments = organizeComments(post.comments);
                const commentsHTML = renderComments(organizedComments,0,post.permalink);
                $('.comments').append(commentsHTML);
                var authToken = localStorage.getItem('authToken');

                scrollToComment();

                $(document).on('click', '.save_comment', function (e) {
                    const $button = $(this);

                    e.preventDefault();
                    const commentId = $(this).closest('.comment').data('commentid');
                    const postId = getThirdPathSegment($(this).closest('.comment').data('postpermalink'));
                    $.ajax({
                        url: '/api/saveComment',
                        type: 'POST',
                        headers: {
                            'Authorization': 'Bearer ' + authToken, // Assume userToken is acquired at login
                            'Content-Type': 'application/json'
                        },
                        data: JSON.stringify({ commentId,postId }),
                        success: function (response) {
                            console.log(response.message);
                            $button.text('saved')
                $button.css({'color':'white'});
                            // Update UI to reflect the saved status
                        },
                        error: function (xhr, status, error) {
                            console.error('Error saving comment:', error);
                        }
                    });
                });

 



                // Assuming this code is placed inside a document ready function and the reply link click handler
                $(document).on('click', '.reply', function (e) {
                    e.preventDefault();
                    var $replyForm = $(this).closest('.comment-content').find('.reply-form').first();
                    $replyForm.show(); // Show the reply form

                    if (!$replyForm.data('quill-initialized')) {
                        var container = $replyForm.find('.reply-input')[0];


                        // Find the submit button within the reply form
                        var $submitButton = $replyForm.find('.submit-reply').first();
                        console.log($submitButton);
                        // Now $submitButton is the jQuery object for the submit button
                        console.log('Submit button post id is:', $submitButton.data('postid'));

                        // Initialize Quill editor if not already initialized
                        quillEditors[$submitButton.data('postid')] = new Quill(container, {
                            modules: {
                                toolbar: [
                                    ['bold', 'italic', 'underline', 'strike', 'blockquote'],        // grouped buttons
                                    [{ 'list': 'ordered' }, { 'list': 'bullet' }],
                                    ['link']  // links and image embed buttons
                                ]
                            },
                            theme: 'snow', // Assuming the Snow theme
                            // other Quill options...
                        });


                        // Add a specific class to the .ql-editor based on the parent's background color
                        var editorClass = $(this).closest('.comment').css('background-color') === 'rgb(38, 38, 38)' ? 'ql-editor-dark' : 'ql-editor-light';
                        $(container).find('.ql-editor').addClass(editorClass);

                        $replyForm.data('quill-initialized', true);
                    }
                });

                $(document).on('click', '.cancel-reply', function (e) {
                    e.preventDefault();

                    var $replyForm = $(this).closest('.comment-content').find('.reply-form').first();
                    $replyForm.hide();


                });
                $(document).on('click', '#submit-comment, .submit-reply', function (e) {
                    e.preventDefault();

                    var $thisButton = $(this);
                    var postReplyingToPostID = $thisButton.data('postid'); // The ID of the post or parent comment
                    var originalPostID = '<%= post.post_id %>'; // Assuming this is provided by your server-side template
                    var commentContent = processHTMLFromUsers(quillEditors[postReplyingToPostID].root.innerHTML); // Content from Quill editor
                    var postPermalink = '<%= post.permalink %>' ? '<%= post.permalink %>' : $thisButton.closest('.comment').data('postpermalink'); 
                    var result = validateComment(commentContent);
                    if (!result.isValid) {

                        var $statusMessage = $thisButton.parent().find('.status-message');

                        $statusMessage.text(result.message).css('color', 'red').show().delay(3000).fadeOut();

                        return;
                    }

                    var $statusMessage = $thisButton.siblings('.status-message'); // Status message related to this comment form

                    // Determine depth for new comment
                    var depth = 0; // Default depth for top-level comments
                    if (postReplyingToPostID !== originalPostID) { // If it's a reply to another comment
                        var $parentComment = $thisButton.closest('.comment');
                        depth = parseInt($parentComment.data('depth')) + 1;
                    }

                    // Show submitting status
                    $statusMessage.text('Submitting...').css('color', 'white').show();


                    const authToken = localStorage.getItem('authToken');
                    const author = localStorage.getItem('username');


                    $.ajax({
                        url: '/api/comment',
                        type: 'POST',
                        contentType: 'application/json',
                        headers: {
                            'Authorization': `Bearer ${authToken}` // Include the auth token in the request headers
                        },
                        data: JSON.stringify({ post_id: originalPostID, content: commentContent, parent_id: postReplyingToPostID, postPermalink: postPermalink }),
                        success: function (response) {

                            const newCommentID = response.commentId;

                            var commentHTML = getCommentHtml(newCommentID, author, commentContent, depth, 1, undefined, postReplyingToPostID, undefined, '<%= post.permalink %>'); // Assuming your getCommentHtml can handle these parameters
                            // Inserting the comment in the correct position
                            if (postReplyingToPostID == originalPostID) {
                                $('.comments').prepend(commentHTML); // Add to the start for top-level comments
                            } else {
                                $thisButton.closest('.comment').after(commentHTML); // Add after the parent comment for nested replies
                            }

                            // Clearing the Quill editor and hiding the reply form
                            if (quillEditors[postReplyingToPostID]) {
                                quillEditors[postReplyingToPostID].setContents([]);
                            }
                            $statusMessage.text('').hide();
                            $thisButton.closest('.reply-form').hide();
                        },
                        error: function (xhr, status, errorMessage) {

                            const responseJson = xhr.responseJSON;
                            const message = responseJson && responseJson.message ? responseJson.message : `Error submitting comment: ${errorMessage}`;
                            $statusMessage.text(message).css('color', 'red').show().delay(10000).fadeOut();
                            // $statusMessage.text(error.includes('error') ? error: 'Error submitting comment: ' + error).css('color', 'red').show().delay(3000).fadeOut();
                        }
                    });
                });


                $('.upvote, .downvote').on('click', function (event) {
                    event.preventDefault();

                });


                $('body').on('click', '.upvote, .downvote', function (event) {
                    event.preventDefault();

                    const $this = $(this);
                    const $votingContext = $this.closest('.voting');
                    const isUpvote = $this.hasClass('upvote');
                    let currentVoteState = $votingContext.data('voteState') || 'none';

                    let newVoteState = 'none';
                    // Determine the new vote state based on the current state and the action
                    if (isUpvote && currentVoteState !== 'up') {
                        newVoteState = 'up';
                    } else if (!isUpvote && currentVoteState !== 'down') {
                        newVoteState = 'down';
                    }

                    // Update vote state or toggle off if the same button was clicked again
                    if (newVoteState === currentVoteState) {
                        newVoteState = 'none'; // Toggle off if the same state was clicked again
                    }

                    // Find the current vote count
                    const $voteCountSpan = $votingContext.find('.votes');
                    let currentCount = parseInt($voteCountSpan.text(), 10);

                    // Adjust the vote count based on the new vote state
                    switch (newVoteState) {
                        case 'up':
                            currentCount = currentVoteState === 'down' ? currentCount + 2 : currentVoteState === 'none' ? currentCount + 1 : currentCount - 1;
                            break;
                        case 'down':
                            currentCount = currentVoteState === 'up' ? currentCount - 2 : currentVoteState === 'none' ? currentCount - 1 : currentCount + 1;
                            break;
                        case 'none':
                            // Undo the vote
                            currentCount = currentVoteState === 'up' ? currentCount - 1 : currentVoteState === 'down' ? currentCount + 1 : currentCount;
                            break;
                    }

                    // Update the vote count and state
                    $voteCountSpan.text(currentCount);
                    $votingContext.data('voteState', newVoteState);

                    // Reset visual state for all buttons
                    $votingContext.find('.upvote, .downvote').removeClass('upvote-active downvote-active');
                    // Apply the active class to the current button, if applicable
                    if (newVoteState !== 'none') {
                        $this.addClass(newVoteState + 'vote-active');
                    }


                    $.ajax({
                        url: `/api/vote/`,
                        type: 'POST',
                        data: {
                            upvote: isUpvote,
                            post_id: $this.data('postid'),
                            root_post_id: '<%= post.post_id %>'
                        },
                        success: function (response) {
                            console.log('Vote recorded successfully.');
                            // You might still want to log the success or handle any sync issues here
                        },
                        error: function (error) {
                            console.error('Failed to record vote:', error);
                            // Since we're optimistically updating the UI, consider how to handle errors
                        }
                    });
                });










            });

            var quillEditors = {};

        </script>



        <div class="container">
            <div style="clear:both;"></div>
            <p id="breadcrumbs"><a href="/" style="color: #bdbdbd">Home</a> » <a href="/c/<%= post.category %>" style="color: #bdbdbd">/c/<%= post.category %></a></p>


            <div class="post-content post-container">
                <div id="post-content-left">
                <div class="voting" id="voting_main">

                    <a title="upvote" description="upvote" href="#" class="upvote"
                        data-postid="<%= post.post_id %>"><img src="/img/up-arrow.svg" alt="Upvote"></a>
                    <span class="votes">
                        <%= post.upvotes - post.downvotes %>
                    </span>
                    <a title="downvote" description="downvote" href="#" class="downvote"
                        data-postid="<%= post.post_id %>"><img src="/img/down-arrow.svg" alt="Downvote"></a>

                </div>

                </div>



                <div id="post-content-right">

                <div id="post_title_container">
                    <h2 id="post-title">
                        <% if (post.post_type === 'url') { %>
                            <a href="<%= post.content %>" target="_blank"><%= post.title %><i class="fas fa-external-link-alt"></i></a>
                          <% } else { %>
                            <%= post.title %>
                          <% } %>
                          
                    </h2>

                    <div id="post_meta">submitted by <a class="post_creator" href="/u/<%= post.author %>"><%= post.author %></a> <span class="timeago"
                                data-timestamp="<%= post.timestamp %>">Loading...</span></div>

                </div>

                </div>
                <div id="selftext">

                    <% if (post.ai_summary && post.ai_summary.trim().length > 0) { %>
                        <div class="post-summary">
                          <%- post.ai_summary %>
                          <span class="ai_summary_heading">AI-generated summary</span>
                        </div>
                      <% } else { %>
                        <div class="post-content">
                          <%- post.content %>
                        </div>
                      <% } %>
                      

                </div>



                <div class="comment-form" id="op_comment_form">
                    <textarea id="comment" placeholder="Add a comment..."></textarea>
                </div>
                <div class="status-message" style="color: red; display: none;"></div>

                <button data-postid="<%= post.post_id %>" type="submit" id="submit-comment">Submit</button>


                <div class="sort-container" style="display: none;">
                    <div class="dropdown">
                        <div class="dropdown-select" tabindex="0"><span class="current-sort">Top</span></div>
                        <div class="dropdown-list">
                            <div class="dropdown-item" data-sort="top">Top</div>
                            <div class="dropdown-item" data-sort="newest">Newest</div>
                            <div class="dropdown-item" data-sort="controversial">Controversial</div>
                        </div>
                    </div>
                </div>


                <div class="comments">

                    <!-- Add more comments here -->
                </div>


            </div>

        </div>



        <%- include('includes/sidebar', { category: category || null }) %>

            </div>

            <script>
                quillEditors['<%= post.post_id %>'] = new Quill('.comment-form', {
                    modules: {
                        toolbar: [
                            ['bold', 'italic', 'underline', 'strike', 'blockquote'],        // grouped buttons
                            [{ 'list': 'ordered' }, { 'list': 'bullet' }],
                            ['link']  // links and image embed buttons
                        ]
                    },
                    theme: 'snow', // Specify theme in configuration
                    placeholder: 'Write a comment...',

                });


                document.querySelectorAll('.timeago').forEach(function (el) {
                    var timestamp = el.getAttribute('data-timestamp');
                    el.innerText = timeAgo(new Date(timestamp));
                });





                // Comment sorting

                document.addEventListener('DOMContentLoaded', function () {
                    var dropdownSelect = document.querySelector('.dropdown-select');
                    var dropdownList = document.querySelector('.dropdown-list');
                    var dropdownItems = document.querySelectorAll('.dropdown-item');

                    // Function to clear current comments
                    function clearComments() {
                        document.querySelector('.comments').innerHTML = '';
                    }

                    // Function to render comments based on sort criteria
                    function sortAndDisplayComments(sortBy) {
                        clearComments();
                        // Assuming 'post.comments' contains your initial comments array
                        // This could also be a fetch request if comments are not stored in the page
                        const sortedComments = organizeComments(post.comments, sortBy);
                        const commentsHTML = renderComments(sortedComments);
                        document.querySelector('.comments').innerHTML = commentsHTML;
                    }

                    // Dropdown interactions
                    dropdownSelect.addEventListener('click', function () {
                        dropdownList.style.display = dropdownList.style.display === 'block' ? 'none' : 'block';
                    });

                    dropdownItems.forEach(function (item) {
                        item.addEventListener('click', function () {
                            // Update the dropdown select label
                            dropdownSelect.querySelector('.current-sort').textContent = this.textContent;
                            dropdownList.style.display = 'none';

                            // Sort and display comments based on selected criteria
                            const sortBy = this.getAttribute('data-sort');
                            sortAndDisplayComments(sortBy);
                        });
                    });

                    // Close dropdown when clicked outside
                    document.addEventListener('click', function (e) {
                        if (!dropdownSelect.contains(e.target)) {
                            dropdownList.style.display = 'none';
                        }
                    }, true);
                });


            </script>



            </body>

</html>