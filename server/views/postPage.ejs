<!DOCTYPE html>
<html lang="en">

<head>

    <title>
        <%= post.title %>
    </title>
   

    <%- include('includes/header') %>


    <script>

   // Convert the post object to a JSON string and parse it back to an object
   var post = JSON.parse('<%- JSON.stringify(post).replace(/'/g, "\\'").replace(/"/g, '\\"') %>');
        console.log(post);
 


        function generateTestComments(count, depth = 0) {
            if (depth > 4) return ''; // Limit depth to 4
            let commentsHtml = '';
            for (let i = 0; i < count; i++) {
                const username = `user${Math.floor(Math.random() * 100)}`;
                const points = `${Math.floor(Math.random() * 10) + 1} points`;
                const timeAgo = `${Math.floor(Math.random() * 59) + 1} minutes ago`;
                // Determine background color based on depth
                const backgroundColor = depth % 2 === 0 ? '#262626' : '#2d2d2d';

                commentsHtml += `
        <div class="comment" style="background-color: ${backgroundColor};">
            <div class="voting">
    
                <a title="upvote" description="upvote" href="#" class="upvote" data-postid="123"><img src="/img/up-arrow.svg" alt="Upvote"></a>
        <span class="votes">123</span>
<a title="downvote" description="downvote" href="#" class="downvote" data-postid="123"><img src="/img/down-arrow.svg" alt="Downvote"></a>



            </div>
            <div class="comment-content">
                <div class="comment-header">
                    <a href="#" class="username">${username}</a>
                    <span class="points">${points}</span>
                    <span class="time">${timeAgo}</span>
                </div>
                <div class="comment-text" style="display: none;"><p>This is a comment. It could be very interesting and contain lots of insightful information. Or it could be asking for more details.</p>
                </div><div class="comment-links">
                    <a href="#">link</a>
                    <a href="#">save</a>
                    <a href="#edit" class="edit">edit</a>

                    <a href="#reply" class="reply">reply</a>
                </div>
                <div class="reply-form" style="display: none;">
                    <div class="reply-input"></div>
                    <div class="status-message" style="color: red; display: none;"></div>
                    <button type="button" class="submit-reply">Submit</button>
                    <button type="button" class="cancel-reply">Cancel</button>

                </div>
                ${generateTestComments(Math.floor(Math.random() * 3), depth + 1)}
            </div>
        </div>
        `;
            }
            return commentsHtml;
        }

        function organizeComments(comments) {
            const commentsMap = {};

            // Initialize each comment with an empty 'replies' array
            comments.forEach(comment => {
                commentsMap[comment.comment_id] = { ...comment, replies: [] };
            });

            // Populate the 'replies' array for parent comments
            comments.forEach(comment => {
                if (comment.parent_id !== comment.post_id) {
                    commentsMap[comment.parent_id].replies.push(commentsMap[comment.comment_id]);
                }
            });

            // Filter out top-level comments (direct replies to the post)
            return comments.filter(comment => comment.parent_id === comment.post_id).map(comment => commentsMap[comment.comment_id]);
        }

        function getCommentHtml(commentId, author, content, depth = 0,votes) {
            const backgroundColor = depth % 2 === 0 ? '#262626' : '#2d2d2d';
            const points = "0 points"; // Placeholder for points
            const timeAgo = "1 hour ago"; // Placeholder for time ago

            return `<div data-depth="${depth}" data-commentid="${commentId}" class="comment" style="background-color: ${backgroundColor}; margin-left: ${depth * 20}px;">
        <div class="voting">

            <a title="upvote" description="upvote" href="#" class="upvote" data-postid="${commentId}"><img src="/img/up-arrow.svg" alt="Upvote"></a>
        <span class="votes">${votes}</span>
<a title="downvote" description="downvote" href="#" class="downvote" data-postid="${commentId}"><img src="/img/down-arrow.svg" alt="Downvote"></a>


        </div>
        <div class="comment-content">
            <div class="comment-header">
                <a href="#" class="username">${author}</a>
                <span class="points">${points}</span>
                <span class="time">${timeAgo}</span>
            </div>
            <div class="comment-text"">${content}</div>
            <div class="comment-links">
                <a href="#">link</a>
                <a href="#">save</a>
                <a href="#edit" class="edit">edit</a>
                <a href="#reply" class="reply">reply</a>
            </div>
            <div class="reply-form" style="display: none;">
                <div class="reply-input"></div>
                <div class="status-message" style="color: red; display: none;"></div>
                <button type="button" class="submit-reply" data-postid="${commentId}">Submit</button>
                <button type="button" class="cancel-reply">Cancel</button>
            </div>
        </div>
    </div>`;
        }



        function renderComments(comments, depth = 0) {
            let html = ''; // Start with an empty string

            comments.forEach(comment => {
                // Use getCommentHtml with individual parameters
                html += getCommentHtml(comment.comment_id, comment.author, comment.content, depth,comment.upvotes - comment.downvotes);

                // Check for replies and recursively render them
                if (comment.replies && comment.replies.length > 0) {
                    html += renderComments(comment.replies, depth + 1); // Increment depth for nested comments
                }
            });

            return html;
        }

        // Use the functions
        const organizedComments = organizeComments(post.comments);
        const commentsHTML = renderComments(organizedComments);

        // In an EJS template, you might then inject commentsHTML where appropriate


        $(document).ready(function () {
            //    $('.comments').append(generateTestComments(100)); // Start with 10 top-level comments
            const organizedComments = organizeComments(post.comments);
            const commentsHTML = renderComments(organizedComments);
            $('.comments').append(commentsHTML);

            // Assuming this code is placed inside a document ready function and the reply link click handler
            $(document).on('click', '.reply', function (e) {
                e.preventDefault();
                var $replyForm = $(this).closest('.comment-content').find('.reply-form').first();
                $replyForm.show(); // Show the reply form

                if (!$replyForm.data('quill-initialized')) {
                    var container = $replyForm.find('.reply-input')[0];


                    // Find the submit button within the reply form
                    var $submitButton = $replyForm.find('.submit-reply').first();
                    console.log($submitButton);
                    // Now $submitButton is the jQuery object for the submit button
                    console.log('Submit button post id is:', $submitButton.data('postid'));

                    // Initialize Quill editor if not already initialized
                    quillEditors[$submitButton.data('postid')] = new Quill(container, {
                        modules: {
                            toolbar: [
                                ['bold', 'italic', 'underline', 'strike', 'blockquote'],        // grouped buttons
                                [{ 'list': 'ordered' }, { 'list': 'bullet' }],
                                ['link']  // links and image embed buttons
                            ]
                        },
                        theme: 'snow', // Assuming the Snow theme
                        // other Quill options...
                    });


                    // Add a specific class to the .ql-editor based on the parent's background color
                    var editorClass = $(this).closest('.comment').css('background-color') === 'rgb(38, 38, 38)' ? 'ql-editor-dark' : 'ql-editor-light';
                    $(container).find('.ql-editor').addClass(editorClass);

                    $replyForm.data('quill-initialized', true);
                }
            });

            $(document).on('click', '.cancel-reply', function (e) {
                e.preventDefault();

                var $replyForm = $(this).closest('.comment-content').find('.reply-form').first();
                $replyForm.hide();


            });
            $(document).on('click', '#submit-comment, .submit-reply', function (e) {
                e.preventDefault();

                var $thisButton = $(this);
                var post_id = $thisButton.data('postid'); // The ID of the post or parent comment
                var truePostId = '<%= post.post_id %>'; // Assuming this is provided by your server-side template
                var commentContent = quillEditors[post_id].root.innerHTML; // Content from Quill editor
                var $statusMessage = $thisButton.siblings('.status-message'); // Status message related to this comment form

                // Determine depth for new comment
                var depth = 0; // Default depth for top-level comments
                if (post_id !== truePostId) { // If it's a reply to another comment
                    var $parentComment = $thisButton.closest('.comment');
                    depth = parseInt($parentComment.data('depth')) + 1;
                }

                // Show submitting status
                $statusMessage.text('Submitting...').css('color', 'white').show();

                $.ajax({
                    url: '/api/comment',
                    type: 'POST',
                    contentType: 'application/json',
                    data: JSON.stringify({ post_id: truePostId, content: commentContent, parent_id: post_id }),
                    success: function (response) {

                        const newCommentID = response.commentId;

                        var commentHTML = getCommentHtml(newCommentID, 'test', commentContent, depth,1); // Assuming your getCommentHtml can handle these parameters
                        // Inserting the comment in the correct position
                        if (post_id == truePostId) {
                            $('.comments').prepend(commentHTML); // Add to the start for top-level comments
                        } else {
                            $thisButton.closest('.comment').after(commentHTML); // Add after the parent comment for nested replies
                        }

                        // Clearing the Quill editor and hiding the reply form
                        if (quillEditors[post_id]) {
                            quillEditors[post_id].setContents([]);
                        }
                        $statusMessage.text('').hide();
                        $thisButton.closest('.reply-form').hide();
                    },
                    error: function (xhr, status, error) {
                        console.error('Error submitting comment', error);
                        $statusMessage.text('Error submitting comment').css('color', 'red').show().delay(3000).fadeOut();
                    }
                });
            });


            $('.upvote, .downvote').on('click', function (event) {
                event.preventDefault();

            });


            $('body').on('click', '.upvote, .downvote', function (event) {
                event.preventDefault();

                const $this = $(this);
                const $votingContext = $this.closest('.voting');
                const isUpvote = $this.hasClass('upvote');
                let currentVoteState = $votingContext.data('voteState') || 'none';

                let newVoteState = 'none';
                // Determine the new vote state based on the current state and the action
                if (isUpvote && currentVoteState !== 'up') {
                    newVoteState = 'up';
                } else if (!isUpvote && currentVoteState !== 'down') {
                    newVoteState = 'down';
                }

                // Update vote state or toggle off if the same button was clicked again
                if (newVoteState === currentVoteState) {
                    newVoteState = 'none'; // Toggle off if the same state was clicked again
                }

                // Find the current vote count
                const $voteCountSpan = $votingContext.find('.votes');
                let currentCount = parseInt($voteCountSpan.text(), 10);

                // Adjust the vote count based on the new vote state
                switch (newVoteState) {
                    case 'up':
                        currentCount = currentVoteState === 'down' ? currentCount + 2 : currentVoteState === 'none' ? currentCount + 1 : currentCount - 1;
                        break;
                    case 'down':
                        currentCount = currentVoteState === 'up' ? currentCount - 2 : currentVoteState === 'none' ? currentCount - 1 : currentCount + 1;
                        break;
                    case 'none':
                        // Undo the vote
                        currentCount = currentVoteState === 'up' ? currentCount - 1 : currentVoteState === 'down' ? currentCount + 1 : currentCount;
                        break;
                }

                // Update the vote count and state
                $voteCountSpan.text(currentCount);
                $votingContext.data('voteState', newVoteState);

                // Reset visual state for all buttons
                $votingContext.find('.upvote, .downvote').removeClass('upvote-active downvote-active');
                // Apply the active class to the current button, if applicable
                if (newVoteState !== 'none') {
                    $this.addClass(newVoteState + 'vote-active');
                }


                $.ajax({
                    url: `/api/vote/`,
                    type: 'POST',
                    data: {
                        upvote: isUpvote,
                        post_id: $this.data('postid'),
                        root_post_id: '<%= post.post_id %>'
                    },
                    success: function (response) {
                        console.log('Vote recorded successfully.');
                        // You might still want to log the success or handle any sync issues here
                    },
                    error: function (error) {
                        console.error('Failed to record vote:', error);
                        // Since we're optimistically updating the UI, consider how to handle errors
                    }
                });
            });


          


            $('body').on('click', '.edit', function (e) {
                e.preventDefault();

                const $comment = $(this).closest('.comment');
                const $commentContent = $comment.find('.comment-content');
                const originalContentHtml = $commentContent.find('.comment-text').html(); // Assuming the comment text is in <p>
                const $commentLinks = $comment.find('.comment-links');
                const postID = $comment.data('commentid');


                // Remove any existing editor to prevent duplicates
                $commentContent.find('.quill-editing, .edit-actions').remove();

                // Hide the original comment content and links
                $commentContent.find('.comment-text, .edit').hide();
                $commentLinks.hide();



                // Determine the current background color of the comment
                const currentBgColor = $comment.css('background-color');
                // Alternate background colors
                const bgColor1 = 'rgb(38, 38, 38)'; // #262626
                const bgColor2 = 'rgb(45, 45, 45)'; // #2d2d2d
                // Determine the new background color
                const newBgColor = currentBgColor === bgColor1 ? bgColor2 : bgColor1;

                // Remove any existing Quill editors to prevent duplicates
                $commentContent.find('.quill-editing').remove();
                $commentContent.find('.comment-text, .edit').hide();

                // Append a Quill editor container
                const quillContainer = $('<div>').addClass('quill-editing ql-container ql-snow').appendTo($commentContent);

                // Initialize Quill on the new container
                const quillEditor = new Quill(quillContainer.get(0), {
                    theme: 'snow',
                    modules: {
                        toolbar: [
                            ['bold', 'italic', 'underline', 'strike', 'blockquote'],
                            [{ 'list': 'ordered' }, { 'list': 'bullet' }],
                            ['link']
                        ]
                    },
                });


                quillEditor.root.innerHTML = originalContentHtml;

                // Apply the determined background color directly to the '.ql-editor' inside the Quill container
                $(quillEditor.root).css('background-color', newBgColor);


                // Append Save and Cancel buttons
                const actionsHtml = `
    <div class="edit-actions">
        <div class="status-message" style="color: red; display: none;"></div>
        <button class="save-edit">Save</button>
        <button class="cancel-edit">Cancel</button>
    </div>`;
                $(actionsHtml).appendTo($commentContent);
                const $toolbar = $comment.find('.ql-toolbar');


                // Handle the cancel action
                $commentContent.find('.cancel-edit').on('click', function () {

                    quillContainer.remove(); // This should correctly remove the Quill editor container
                    $toolbar.remove();
                    $commentContent.find('.edit-actions').remove(); // Remove the action buttons
                    $commentContent.find('.comment-text, .edit').show(); // Show the original content and edit link
                    $commentLinks.show(); // Show the comment links again
                });

                // Handle save (similar to your submit logic but for updating existing comments)
                const saveBtn = $comment.find('.save-edit');
                const cancelBtn = $comment.find('.cancel-edit');



                saveBtn.on('click', function () {
                    const updatedContent = quillEditor.root.innerHTML;
                    $.ajax({
                        url: '/api/comment',
                        type: 'POST',
                        contentType: 'application/json',
                        data: JSON.stringify({ commentId: postID, post_id: '<%= post.post_id %>', content: updatedContent, isEdit: true }),
                        success: function (response) {
                            console.log('edit comment success');
                            quillContainer.remove();
                            $toolbar.remove();

                            console.log(updatedContent);

                            $commentContent.find('.comment-text').html(updatedContent).show();
                            quillEditor.container.remove();
                            saveBtn.remove();
                            cancelBtn.remove();
                            $commentContent.find('.edit').show();
                            $commentLinks.show();

                        },
                        error: function (xhr, status, error) {
                            var $statusMessage = $comment.find('.status-message');
                            console.error('Error submitting comment', error);
                            $statusMessage.text('Error submitting comment').css('color', 'red').show().delay(3000).fadeOut();
                        }
                    });


                });



            });






        });

        var quillEditors = {};


    </script>




</head>

<body>
    <div class="container">
        <a href="/"><img id="logo_satori1" src="/branding/satori3.png" /></a>
        <div style="clear:both;"></div>

        <div class="sort-container">
            <select id="sort-by" name="sort-by">
                <option value="top">Top</option>
                <option value="new" selected>Latest</option>
                <option value="hot">Hot</option>
            </select>
        </div>

        <div class="post-content">
            <div class="voting" id="voting_main">

                <a title="upvote" description="upvote" href="#" class="upvote" data-postid="<%= post.post_id %>"><img
                        src="/img/up-arrow.svg" alt="Upvote"></a>
                <span class="votes">
                    <%= post.upvotes - post.downvotes %>
                </span>
                <a title="downvote" description="downvote" href="#" class="downvote"
                    data-postid="<%= post.post_id %>"><img src="/img/down-arrow.svg" alt="Downvote"></a>

            </div>
            <h2 id="post-title">
                <%= post.title %>
            </h2>

            <div id="selftext">
                
                    <%- post.content %>
                
            </div>
            


            <div class="comment-form" id="op_comment_form">
                <textarea id="comment" placeholder="Add a comment..."></textarea>
            </div>
            <div class="status-message" style="color: red; display: none;"></div>

            <button data-postid="<%= post.post_id %>" type="submit" id="submit-comment">Submit</button>



            <div class="comments">

                <!-- Add more comments here -->
            </div>


        </div>

    </div>



    <%- include('includes/sidebar') %>

</div>

    <script>
        quillEditors['<%= post.post_id %>'] = new Quill('.comment-form', {
            modules: {
                toolbar: [
                    ['bold', 'italic', 'underline', 'strike', 'blockquote'],        // grouped buttons
                    [{ 'list': 'ordered' }, { 'list': 'bullet' }],
                    ['link']  // links and image embed buttons
                ]
            },
            theme: 'snow', // Specify theme in configuration
            placeholder: 'Write a comment...',

        });
    </script>



</body>

</html>